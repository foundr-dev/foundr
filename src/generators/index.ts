/**
 * Infrastructure generators - create files based on configuration
 */

import { mkdir, writeFile } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import { stringify as stringifyYaml } from "yaml";
import type { FoundrConfig, ProjectAnalysis } from "../core/types.ts";

export interface GenerationResult {
  createdFiles: string[];
  skippedFiles: string[];
}

/**
 * Generate foundr infrastructure based on configuration
 */
export async function generateInfrastructure(
  projectRoot: string,
  config: FoundrConfig,
  analysis: ProjectAnalysis | null
): Promise<GenerationResult> {
  const createdFiles: string[] = [];
  const skippedFiles: string[] = [];

  // Create .claude directory structure
  const claudeDir = join(projectRoot, ".claude");
  await ensureDir(claudeDir);
  await ensureDir(join(claudeDir, "agents"));
  await ensureDir(join(claudeDir, "commands"));
  await ensureDir(join(claudeDir, "skills"));
  await ensureDir(join(claudeDir, "hooks"));
  await ensureDir(join(claudeDir, "docs"));

  // Generate foundr.yaml config
  const configPath = join(projectRoot, "foundr.yaml");
  if (!existsSync(configPath)) {
    await writeFile(configPath, stringifyYaml(config, { indent: 2 }));
    createdFiles.push("foundr.yaml");
  } else {
    skippedFiles.push("foundr.yaml (exists)");
  }

  // Generate CLAUDE.md
  const claudeMdPath = join(projectRoot, "CLAUDE.md");
  if (!existsSync(claudeMdPath)) {
    const claudeMdContent = generateClaudeMd(config, analysis);
    await writeFile(claudeMdPath, claudeMdContent);
    createdFiles.push("CLAUDE.md");
  } else {
    skippedFiles.push("CLAUDE.md (exists)");
  }

  // Generate .claude/README.md
  const readmePath = join(claudeDir, "README.md");
  if (!existsSync(readmePath)) {
    await writeFile(readmePath, generateClaudeReadme(config));
    createdFiles.push(".claude/README.md");
  }

  // Generate registry.yaml
  const registryPath = join(claudeDir, "registry.yaml");
  if (!existsSync(registryPath)) {
    await writeFile(registryPath, generateRegistry(config));
    createdFiles.push(".claude/registry.yaml");
  }

  // Generate agents based on preset
  const agentFiles = await generateAgents(claudeDir, config);
  createdFiles.push(...agentFiles);

  // Generate commands based on preset
  const commandFiles = await generateCommands(claudeDir, config);
  createdFiles.push(...commandFiles);

  // Generate OpenCode AGENTS.md if opencode is selected
  if (config.aiTools.includes("opencode")) {
    const agentsMdPath = join(projectRoot, "AGENTS.md");
    if (!existsSync(agentsMdPath)) {
      await writeFile(agentsMdPath, generateAgentsMd(config));
      createdFiles.push("AGENTS.md");
    }
  }

  return { createdFiles, skippedFiles };
}

async function ensureDir(dir: string): Promise<void> {
  if (!existsSync(dir)) {
    await mkdir(dir, { recursive: true });
  }
}

function generateClaudeMd(config: FoundrConfig, analysis: ProjectAnalysis | null): string {
  const sections: string[] = [];

  // Header
  sections.push(`# Project Context for AI Assistants

> Generated by [foundr](https://github.com/foundr-dev/foundr)

## Overview

This project uses foundr to manage AI development infrastructure.`);

  // Project info
  if (analysis) {
    sections.push(`
## Project Structure

- **Type**: ${analysis.projectType}
- **Languages**: ${analysis.languages.map(l => l.name).join(", ")}
- **Main Branch**: ${analysis.gitBranch}`);

    if (analysis.services.length > 0) {
      sections.push(`
### Services

${analysis.services.map(s => `- \`${s}/\``).join("\n")}`);
    }
  }

  // Quick start
  sections.push(`
## Quick Start

\`\`\`bash
# Common commands
/commit          # Create conventional commit
/ship            # Commit, push, create PR
/morning         # Daily sync
\`\`\`

## Available Tools

- **Agents**: See \`.claude/agents/\` for specialized task handlers
- **Commands**: See \`.claude/commands/\` for quick actions
- **Skills**: See \`.claude/skills/\` for on-demand context`);

  // AI tools
  sections.push(`
## AI Tools

This project is configured for: ${config.aiTools.join(", ")}`);

  if (config.aiTools.includes("claude")) {
    sections.push(`
### Claude Code

- Configuration: \`.claude/\`
- Registry: \`.claude/registry.yaml\``);
  }

  if (config.aiTools.includes("opencode")) {
    sections.push(`
### OpenCode

- Configuration: \`AGENTS.md\``);
  }

  // Documentation pointer
  sections.push(`
## Documentation

See \`.claude/README.md\` for full documentation on available agents, commands, and workflows.`);

  return sections.join("\n");
}

function generateClaudeReadme(config: FoundrConfig): string {
  return `# Claude Infrastructure

> Managed by [foundr](https://github.com/foundr-dev/foundr)

## Directory Structure

\`\`\`
.claude/
├── agents/      # Specialized task handlers
├── commands/    # Slash commands for quick actions
├── skills/      # On-demand context loading
├── hooks/       # Event handlers
├── docs/        # Reference documentation
└── registry.yaml # Component registry
\`\`\`

## Preset: ${config.preset}

This installation uses the **${config.preset}** preset.

## Registry

The \`registry.yaml\` file is the single source of truth for all components.

## Updating

Run \`foundr update\` to get the latest patterns while preserving your customizations.
`;
}

function generateRegistry(config: FoundrConfig): string {
  const registry = {
    version: "1.0.0",
    preset: config.preset,
    agents: {} as Record<string, object>,
    commands: {} as Record<string, object>,
    skills: {} as Record<string, object>,
    hooks: {} as Record<string, object>,
  };

  // Add agents based on preset
  if (config.preset === "standard" || config.preset === "full") {
    registry.agents["commit-author"] = {
      path: "agents/git/commit-author.md",
      triggers: ["commit", "message"],
      description: "Create well-structured conventional commits",
    };

    registry.commands["commit"] = {
      path: "commands/commit.md",
      triggers: ["commit"],
      description: "Create conventional commit",
    };

    registry.commands["ship"] = {
      path: "commands/ship.md",
      triggers: ["ship", "push", "pr"],
      description: "Commit, push, and create PR",
    };
  }

  if (config.preset === "full") {
    registry.agents["daily-sync"] = {
      path: "agents/lifecycle/daily-sync.md",
      triggers: ["morning", "sync", "status"],
      description: "Check PRs, tasks, and suggest focus",
    };

    registry.commands["morning"] = {
      path: "commands/morning.md",
      triggers: ["morning", "daily"],
      description: "Daily sync routine",
    };
  }

  return stringifyYaml(registry, { indent: 2 });
}

async function generateAgents(claudeDir: string, config: FoundrConfig): Promise<string[]> {
  const created: string[] = [];

  if (config.preset === "minimal") {
    return created;
  }

  // Git agents directory
  const gitAgentsDir = join(claudeDir, "agents", "git");
  await ensureDir(gitAgentsDir);

  // Commit author agent
  const commitAuthorPath = join(gitAgentsDir, "commit-author.md");
  if (!existsSync(commitAuthorPath)) {
    await writeFile(commitAuthorPath, `# Commit Author Agent

Create well-structured conventional commits.

## Triggers
- "commit my changes"
- "create commit"

## Workflow
1. Run \`git status\` and \`git diff\` to understand changes
2. Analyze the changes to determine commit type
3. Generate commit message following conventional commits
4. Create the commit with proper attribution

## Commit Types
- \`feat:\` - New feature
- \`fix:\` - Bug fix
- \`docs:\` - Documentation
- \`style:\` - Formatting
- \`refactor:\` - Code restructuring
- \`test:\` - Tests
- \`chore:\` - Maintenance
`);
    created.push(".claude/agents/git/commit-author.md");
  }

  return created;
}

async function generateCommands(claudeDir: string, config: FoundrConfig): Promise<string[]> {
  const created: string[] = [];

  if (config.preset === "minimal") {
    return created;
  }

  // Commit command
  const commitPath = join(claudeDir, "commands", "commit.md");
  if (!existsSync(commitPath)) {
    await writeFile(commitPath, `# /commit

Create a conventional commit for staged changes.

## Usage
\`\`\`
/commit
/commit fix: resolve login issue
\`\`\`

## Behavior
1. Check for staged changes
2. Generate or use provided commit message
3. Follow conventional commit format
4. Include attribution footer
`);
    created.push(".claude/commands/commit.md");
  }

  // Ship command
  const shipPath = join(claudeDir, "commands", "ship.md");
  if (!existsSync(shipPath)) {
    await writeFile(shipPath, `# /ship

Commit, push, and create a pull request.

## Usage
\`\`\`
/ship
/ship [task-id]
\`\`\`

## Behavior
1. Commit staged changes (if any)
2. Push to remote
3. Create pull request
4. Link to task management (if configured)
`);
    created.push(".claude/commands/ship.md");
  }

  return created;
}

function generateAgentsMd(_config: FoundrConfig): string {
  return `# Agents

> OpenCode agent definitions - Generated by [foundr](https://github.com/foundr-dev/foundr)

## Available Agents

### commit-author
Create well-structured conventional commits.

**Triggers**: commit, message

### ship
Commit, push, and create a pull request in one command.

**Triggers**: ship, push, pr

## Usage

Invoke agents by describing your task. The AI will select the appropriate agent.

Example:
\`\`\`
"commit my changes"
"ship this feature"
\`\`\`
`;
}
